{
  "permissions": {
    "allow": [
      "Bash(tail:*)",
      "Bash(find:*)",
      "Bash(head:*)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"from sklearn.linear_model import LassoLarsIC; l = LassoLarsIC\\(criterion='bic', max_iter=1000, normalize=False\\)\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"import sklearn; print\\('scikit-learn:', sklearn.__version__\\); import numpy; print\\('numpy:', numpy.__version__\\); import pandas; print\\('pandas:', pandas.__version__\\); import scipy; print\\('scipy:', scipy.__version__\\)\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport numpy as np\nimport sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_linear_te_matrix\n\n# Generate data with known structure \\(x -> y\\)\nnp.random.seed\\(42\\)\nT = 500\nx = np.random.randn\\(T\\)\ny = np.zeros\\(T\\)\nfor t in range\\(1, T\\):\n    y[t] = 0.5 * y[t-1] + 0.3 * x[t-1] + np.random.randn\\(\\)\nR = np.column_stack\\([x, y]\\)\n\n# Test LASSO\nTE_lasso, A_lasso = compute_linear_te_matrix\\(R, method='lasso'\\)\nprint\\('LASSO edges detected:', A_lasso.sum\\(\\)\\)\nprint\\('LASSO TE matrix sum:', TE_lasso.sum\\(\\)\\)\n\n# Test OLS for comparison\nTE_ols, A_ols = compute_linear_te_matrix\\(R, method='ols'\\)\nprint\\('OLS edges detected:', A_ols.sum\\(\\)\\)\nprint\\('OLS TE matrix sum:', TE_ols.sum\\(\\)\\)\n\" 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -c \"\nimport numpy as np\nimport sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_nio\n\n# Create a TE matrix where node 0 is a clear hub \\(causes nodes 1,2,3\\)\n# Convention: A[i,j]=1 means j->i\n# So hub node 0 causing 1,2,3 means: A[1,0]=1, A[2,0]=1, A[3,0]=1\nN = 4\nA = np.zeros\\(\\(N, N\\)\\)\nA[1, 0] = 1  # 0 -> 1\nA[2, 0] = 1  # 0 -> 2\nA[3, 0] = 1  # 0 -> 3\n\nprint\\('Adjacency matrix \\(A[i,j]=1 means j->i\\):'\\)\nprint\\(A\\)\nprint\\(\\)\nprint\\('Out-degree \\(should be: node0=3, rest=0\\):'\\)\nprint\\('  A.sum\\(axis=0\\) =', A.sum\\(axis=0\\), ' \\(column sums = true out-degree\\)'\\)\nprint\\('  A.sum\\(axis=1\\) =', A.sum\\(axis=1\\), ' \\(row sums = true in-degree\\)'\\)\nprint\\(\\)\n\nnio = compute_nio\\(A, method='binary'\\)\nprint\\('NIO from compute_nio\\(\\):', nio\\)\nprint\\(\\)\nprint\\('Expected: node 0 should have HIGHEST NIO \\(it transmits info\\)'\\)\nprint\\('Actual: node 0 has NIO =', nio[0]\\)\nprint\\('Is node 0 max?', np.argmax\\(nio\\) == 0\\)\n\" 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -m pytest test_algorithms.py -v 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -c \"\nimport numpy as np, sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_linear_te_matrix, compute_nio\n\n# Test 1: LASSO functionality\nnp.random.seed\\(42\\)\nT = 500\nx = np.random.randn\\(T\\)\ny = np.zeros\\(T\\)\nfor t in range\\(1, T\\):\n    y[t] = 0.5*y[t-1] + 0.3*x[t-1] + np.random.randn\\(\\)\nR = np.column_stack\\([x, y]\\)\n_, A_lasso = compute_linear_te_matrix\\(R, method='lasso'\\)\nprint\\('LASSO edges:', A_lasso.sum\\(\\), '\\(should be >= 1\\)'\\)\n\n# Test 2: NIO direction\nN = 4\nA = np.zeros\\(\\(N, N\\)\\)\nA[1,0]=1; A[2,0]=1; A[3,0]=1  # 0 causes 1,2,3\nnio = compute_nio\\(A, method='binary'\\)\nprint\\('NIO of transmitter \\(node 0\\):', nio[0], '\\(should be positive/highest\\)'\\)\nprint\\('NIO of receiver \\(node 1\\):', nio[1], '\\(should be negative\\)'\\)\n\" 2>&1)",
      "Bash(sort -k2)",
      "Bash(grep:*)",
      "Bash(wc:*)",
      "Bash(cd:*)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -m pytest test_algorithms.py -v 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nimport numpy as np\nfrom dgp import generate_sparse_var\nfrom factor_neutral_preprocessing import preprocess_returns\nfrom te_core import compute_linear_te_matrix, compute_nio\nfrom evaluation import eval_metrics\n\n# Replicate exact logic of Exp #3 with small parameters\nK = 3\nN, T = 10, 30\nseed = 42\n\nR, A_coef, A_true, F_true = generate_sparse_var\\(\n    N=N, T=T, density=0.05, dgp='garch_factor', seed=seed, return_factors=True\n\\)\n\n# The FIXED call signatures \\(P0-A\\)\nR_oracle, _ = preprocess_returns\\(R, mode='oracle_fn', true_factors=F_true\\)\nR_est, _ = preprocess_returns\\(R, mode='estimated_fn', n_factors=K\\)\n\n# Run TE on all 3 preprocessing modes\nfor Rdata, label in [\\(R,'Raw'\\),\\(R_oracle,'Oracle'\\),\\(R_est,'Estimated\\(PCA\\)'\\)]:\n    for mname in ['OLS', 'LASSO']:\n        method = 'ols' if mname == 'OLS' else 'lasso'\n        _, A_pred = compute_linear_te_matrix\\(Rdata, method=method, t_threshold=2.0\\)\n        m = eval_metrics\\(A_true, A_pred\\)\n        print\\(f'{label:20s} {mname:6s}  P={m[\\\\\"precision\\\\\"]:.3f}  R={m[\\\\\"recall\\\\\"]:.3f}  F1={m[\\\\\"f1\\\\\"]:.3f}  hub={m[\\\\\"hub_recovery\\\\\"]:.3f}'\\)\n\nprint\\(\\)\nprint\\('Exp #3 logic fully verified - all preprocessing modes + estimators work.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python src/all_experiments_v2.py --help 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nfrom evaluation import eval_metrics\nimport numpy as np\n\nA_true = np.eye\\(5\\)\nA_pred = np.eye\\(5\\)\nm = eval_metrics\\(A_true, A_pred\\)\nprint\\('eval_metrics keys:', list\\(m.keys\\(\\)\\)\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nfrom evaluation import eval_metrics\nimport numpy as np\n\n# Verify kendall_tau is now in the dict\nA_true = np.zeros\\(\\(10, 10\\)\\)\nA_true[1,0] = 1; A_true[2,0] = 1; A_true[3,0] = 1  # Node 0 has out-edges\nA_pred = A_true.copy\\(\\)\nm = eval_metrics\\(A_true, A_pred, top_k=3\\)\nprint\\('eval_metrics keys:', list\\(m.keys\\(\\)\\)\\)\nprint\\(f'  kendall_tau: {m[\\\\\"kendall_tau\\\\\"]:.3f}'\\)\nprint\\(f'  hub_recovery: {m[\\\\\"hub_recovery\\\\\"]:.3f}'\\)\nprint\\(f'  precision: {m[\\\\\"precision\\\\\"]:.3f}'\\)\nprint\\(\\)\n\n# Verify Table 2 pipeline works end-to-end\nfrom dgp import generate_sparse_var\nfrom factor_neutral_preprocessing import preprocess_returns\nfrom te_core import compute_linear_te_matrix\n\nR, _, A_true = generate_sparse_var\\(N=20, T=100, density=0.05, seed=42, dgp='garch_factor'\\)\nR_proc, _ = preprocess_returns\\(R, mode='estimated_fn', n_factors=3\\)\n_, A_est = compute_linear_te_matrix\\(R_proc, method='ols', t_threshold=2.0\\)\nm = eval_metrics\\(A_true, A_est\\)\nprint\\('Table 2 pipeline end-to-end:'\\)\nfor k, v in m.items\\(\\):\n    print\\(f'  {k}: {v:.4f}'\\)\nprint\\(\\)\nprint\\('All pipeline checks passed.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport ast, sys\n# Syntax check all modified Python files\nfiles = [\n    'src/all_experiments_v2.py',\n    'src/evaluation.py',\n    'src/factor_neutral_preprocessing.py',\n    'src/run_factor_neutral_sim.py',\n    'run_experiments_modular.py',\n]\nfor f in files:\n    try:\n        with open\\(f, encoding='utf-8'\\) as fh:\n            ast.parse\\(fh.read\\(\\)\\)\n        print\\(f'  OK  {f}'\\)\n    except SyntaxError as e:\n        print\\(f'  FAIL {f}: {e}'\\)\nprint\\(\\)\nprint\\('All files syntactically valid.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python src/all_experiments_v2.py --help 2>&1 && python src/run_factor_neutral_sim.py --help 2>&1)"
    ]
  }
}

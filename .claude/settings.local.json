{
  "permissions": {
    "allow": [
      "Bash(tail:*)",
      "Bash(find:*)",
      "Bash(head:*)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"from sklearn.linear_model import LassoLarsIC; l = LassoLarsIC\\(criterion='bic', max_iter=1000, normalize=False\\)\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"import sklearn; print\\('scikit-learn:', sklearn.__version__\\); import numpy; print\\('numpy:', numpy.__version__\\); import pandas; print\\('pandas:', pandas.__version__\\); import scipy; print\\('scipy:', scipy.__version__\\)\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport numpy as np\nimport sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_linear_te_matrix\n\n# Generate data with known structure \\(x -> y\\)\nnp.random.seed\\(42\\)\nT = 500\nx = np.random.randn\\(T\\)\ny = np.zeros\\(T\\)\nfor t in range\\(1, T\\):\n    y[t] = 0.5 * y[t-1] + 0.3 * x[t-1] + np.random.randn\\(\\)\nR = np.column_stack\\([x, y]\\)\n\n# Test LASSO\nTE_lasso, A_lasso = compute_linear_te_matrix\\(R, method='lasso'\\)\nprint\\('LASSO edges detected:', A_lasso.sum\\(\\)\\)\nprint\\('LASSO TE matrix sum:', TE_lasso.sum\\(\\)\\)\n\n# Test OLS for comparison\nTE_ols, A_ols = compute_linear_te_matrix\\(R, method='ols'\\)\nprint\\('OLS edges detected:', A_ols.sum\\(\\)\\)\nprint\\('OLS TE matrix sum:', TE_ols.sum\\(\\)\\)\n\" 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -c \"\nimport numpy as np\nimport sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_nio\n\n# Create a TE matrix where node 0 is a clear hub \\(causes nodes 1,2,3\\)\n# Convention: A[i,j]=1 means j->i\n# So hub node 0 causing 1,2,3 means: A[1,0]=1, A[2,0]=1, A[3,0]=1\nN = 4\nA = np.zeros\\(\\(N, N\\)\\)\nA[1, 0] = 1  # 0 -> 1\nA[2, 0] = 1  # 0 -> 2\nA[3, 0] = 1  # 0 -> 3\n\nprint\\('Adjacency matrix \\(A[i,j]=1 means j->i\\):'\\)\nprint\\(A\\)\nprint\\(\\)\nprint\\('Out-degree \\(should be: node0=3, rest=0\\):'\\)\nprint\\('  A.sum\\(axis=0\\) =', A.sum\\(axis=0\\), ' \\(column sums = true out-degree\\)'\\)\nprint\\('  A.sum\\(axis=1\\) =', A.sum\\(axis=1\\), ' \\(row sums = true in-degree\\)'\\)\nprint\\(\\)\n\nnio = compute_nio\\(A, method='binary'\\)\nprint\\('NIO from compute_nio\\(\\):', nio\\)\nprint\\(\\)\nprint\\('Expected: node 0 should have HIGHEST NIO \\(it transmits info\\)'\\)\nprint\\('Actual: node 0 has NIO =', nio[0]\\)\nprint\\('Is node 0 max?', np.argmax\\(nio\\) == 0\\)\n\" 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -m pytest test_algorithms.py -v 2>&1)",
      "Bash(cd \"/c/Users/soray/.openclaw/workspace/te-network-audit\" && python -c \"\nimport numpy as np, sys\nsys.path.insert\\(0, 'src'\\)\nfrom algorithms import compute_linear_te_matrix, compute_nio\n\n# Test 1: LASSO functionality\nnp.random.seed\\(42\\)\nT = 500\nx = np.random.randn\\(T\\)\ny = np.zeros\\(T\\)\nfor t in range\\(1, T\\):\n    y[t] = 0.5*y[t-1] + 0.3*x[t-1] + np.random.randn\\(\\)\nR = np.column_stack\\([x, y]\\)\n_, A_lasso = compute_linear_te_matrix\\(R, method='lasso'\\)\nprint\\('LASSO edges:', A_lasso.sum\\(\\), '\\(should be >= 1\\)'\\)\n\n# Test 2: NIO direction\nN = 4\nA = np.zeros\\(\\(N, N\\)\\)\nA[1,0]=1; A[2,0]=1; A[3,0]=1  # 0 causes 1,2,3\nnio = compute_nio\\(A, method='binary'\\)\nprint\\('NIO of transmitter \\(node 0\\):', nio[0], '\\(should be positive/highest\\)'\\)\nprint\\('NIO of receiver \\(node 1\\):', nio[1], '\\(should be negative\\)'\\)\n\" 2>&1)",
      "Bash(sort -k2)",
      "Bash(grep:*)",
      "Bash(wc:*)",
      "Bash(cd:*)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -m pytest test_algorithms.py -v 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nimport numpy as np\nfrom dgp import generate_sparse_var\nfrom factor_neutral_preprocessing import preprocess_returns\nfrom te_core import compute_linear_te_matrix, compute_nio\nfrom evaluation import eval_metrics\n\n# Replicate exact logic of Exp #3 with small parameters\nK = 3\nN, T = 10, 30\nseed = 42\n\nR, A_coef, A_true, F_true = generate_sparse_var\\(\n    N=N, T=T, density=0.05, dgp='garch_factor', seed=seed, return_factors=True\n\\)\n\n# The FIXED call signatures \\(P0-A\\)\nR_oracle, _ = preprocess_returns\\(R, mode='oracle_fn', true_factors=F_true\\)\nR_est, _ = preprocess_returns\\(R, mode='estimated_fn', n_factors=K\\)\n\n# Run TE on all 3 preprocessing modes\nfor Rdata, label in [\\(R,'Raw'\\),\\(R_oracle,'Oracle'\\),\\(R_est,'Estimated\\(PCA\\)'\\)]:\n    for mname in ['OLS', 'LASSO']:\n        method = 'ols' if mname == 'OLS' else 'lasso'\n        _, A_pred = compute_linear_te_matrix\\(Rdata, method=method, t_threshold=2.0\\)\n        m = eval_metrics\\(A_true, A_pred\\)\n        print\\(f'{label:20s} {mname:6s}  P={m[\\\\\"precision\\\\\"]:.3f}  R={m[\\\\\"recall\\\\\"]:.3f}  F1={m[\\\\\"f1\\\\\"]:.3f}  hub={m[\\\\\"hub_recovery\\\\\"]:.3f}'\\)\n\nprint\\(\\)\nprint\\('Exp #3 logic fully verified - all preprocessing modes + estimators work.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python src/all_experiments_v2.py --help 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nfrom evaluation import eval_metrics\nimport numpy as np\n\nA_true = np.eye\\(5\\)\nA_pred = np.eye\\(5\\)\nm = eval_metrics\\(A_true, A_pred\\)\nprint\\('eval_metrics keys:', list\\(m.keys\\(\\)\\)\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys; sys.path.insert\\(0, 'src'\\)\nfrom evaluation import eval_metrics\nimport numpy as np\n\n# Verify kendall_tau is now in the dict\nA_true = np.zeros\\(\\(10, 10\\)\\)\nA_true[1,0] = 1; A_true[2,0] = 1; A_true[3,0] = 1  # Node 0 has out-edges\nA_pred = A_true.copy\\(\\)\nm = eval_metrics\\(A_true, A_pred, top_k=3\\)\nprint\\('eval_metrics keys:', list\\(m.keys\\(\\)\\)\\)\nprint\\(f'  kendall_tau: {m[\\\\\"kendall_tau\\\\\"]:.3f}'\\)\nprint\\(f'  hub_recovery: {m[\\\\\"hub_recovery\\\\\"]:.3f}'\\)\nprint\\(f'  precision: {m[\\\\\"precision\\\\\"]:.3f}'\\)\nprint\\(\\)\n\n# Verify Table 2 pipeline works end-to-end\nfrom dgp import generate_sparse_var\nfrom factor_neutral_preprocessing import preprocess_returns\nfrom te_core import compute_linear_te_matrix\n\nR, _, A_true = generate_sparse_var\\(N=20, T=100, density=0.05, seed=42, dgp='garch_factor'\\)\nR_proc, _ = preprocess_returns\\(R, mode='estimated_fn', n_factors=3\\)\n_, A_est = compute_linear_te_matrix\\(R_proc, method='ols', t_threshold=2.0\\)\nm = eval_metrics\\(A_true, A_est\\)\nprint\\('Table 2 pipeline end-to-end:'\\)\nfor k, v in m.items\\(\\):\n    print\\(f'  {k}: {v:.4f}'\\)\nprint\\(\\)\nprint\\('All pipeline checks passed.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport ast, sys\n# Syntax check all modified Python files\nfiles = [\n    'src/all_experiments_v2.py',\n    'src/evaluation.py',\n    'src/factor_neutral_preprocessing.py',\n    'src/run_factor_neutral_sim.py',\n    'run_experiments_modular.py',\n]\nfor f in files:\n    try:\n        with open\\(f, encoding='utf-8'\\) as fh:\n            ast.parse\\(fh.read\\(\\)\\)\n        print\\(f'  OK  {f}'\\)\n    except SyntaxError as e:\n        print\\(f'  FAIL {f}: {e}'\\)\nprint\\(\\)\nprint\\('All files syntactically valid.'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python src/all_experiments_v2.py --help 2>&1 && python src/run_factor_neutral_sim.py --help 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys\nsys.path.insert\\(0, 'src'\\)\nimport numpy as np\nfrom algorithms import compute_nio, compute_linear_te_matrix\n\n# Test 1: NIO direction correctness\nprint\\('=== Test 1: NIO Direction ==='\\)\nN = 5\nte = np.zeros\\(\\(N, N\\)\\)\n# Node 0 is a pure sender: te[i, 0] = 1 for i != 0 \\(j=0 causes i\\)\nte[1, 0] = 1.0; te[2, 0] = 1.0; te[3, 0] = 1.0; te[4, 0] = 1.0\nnio = compute_nio\\(te, method='binary'\\)\nprint\\(f'Node 0 \\(sender\\): NIO = {nio[0]:.4f} \\(should be +1.0\\)'\\)\nprint\\(f'Node 1 \\(receiver\\): NIO = {nio[1]:.4f} \\(should be -0.25\\)'\\)\nassert nio[0] == 1.0, f'FAIL: sender NIO should be 1.0, got {nio[0]}'\nassert nio[1] == -1/4, f'FAIL: receiver NIO should be -0.25, got {nio[1]}'\nprint\\('PASS'\\)\n\n# Test 2: Hub recovery axis in evaluation\nprint\\(\\)\nprint\\('=== Test 2: Hub Recovery Axis ==='\\)\nfrom evaluation import eval_metrics\nA_true = np.zeros\\(\\(5, 5\\)\\)\n# Node 0 sends to all: A_true[i,0] = 1 for i!=0\nA_true[1,0] = 1; A_true[2,0] = 1; A_true[3,0] = 1; A_true[4,0] = 1\n# Predicted: same\nA_pred = A_true.copy\\(\\)\nm = eval_metrics\\(A_true, A_pred, top_k=1\\)\n# Top hub by out-degree \\(col sums\\): node 0 has 4\ntop_true = np.argsort\\(A_true.sum\\(axis=0\\)\\)[-1]\ntop_pred = np.argsort\\(A_pred.sum\\(axis=0\\)\\)[-1]\nprint\\(f'Top true hub \\(by col sum\\): node {top_true} \\(should be 0\\)'\\)\nprint\\(f'Hub recovery: {m[\\\\\"hub_recovery\\\\\"]:.2f} \\(should be 1.0\\)'\\)\nassert top_true == 0, f'FAIL: top hub should be 0, got {top_true}'\nassert m['hub_recovery'] == 1.0, f'FAIL: hub recovery should be 1.0'\nprint\\('PASS'\\)\n\n# Test 3: kendall_tau key exists in eval_metrics\nprint\\(\\)\nprint\\('=== Test 3: eval_metrics returns kendall_tau ==='\\)\nassert 'kendall_tau' in m, 'FAIL: kendall_tau missing from eval_metrics'\nprint\\(f'kendall_tau: {m[\\\\\"kendall_tau\\\\\"]:.4f}'\\)\nprint\\('PASS'\\)\n\n# Test 4: preprocess_returns signature\nprint\\(\\)\nprint\\('=== Test 4: preprocess_returns signature ==='\\)\nfrom factor_neutral_preprocessing import preprocess_returns\nimport inspect\nsig = inspect.signature\\(preprocess_returns\\)\nparams = list\\(sig.parameters.keys\\(\\)\\)\nprint\\(f'Parameters: {params}'\\)\nassert 'mode' in params, 'FAIL: mode not in params'\nassert 'true_factors' in params, 'FAIL: true_factors not in params'\nprint\\('PASS'\\)\nprint\\(\\)\nprint\\('ALL TARGETED TESTS PASSED'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport hashlib\n# Verify SHA256 of empirical data\nsha256 = hashlib.sha256\\(\\)\nwith open\\('data/empirical/te_features_weekly.csv', 'rb'\\) as f:\n    for chunk in iter\\(lambda: f.read\\(8192\\), b''\\):\n        sha256.update\\(chunk\\)\ncomputed = sha256.hexdigest\\(\\)\nexpected = '87544851c75673c0cc99823953ce90d917210a5312d7342dab83f8795d380056'\nprint\\(f'Computed: {computed}'\\)\nprint\\(f'Expected: {expected}'\\)\nprint\\(f'Match: {computed == expected}'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys\nsys.path.insert\\(0, 'src'\\)\n# Test that all_experiments_v2.py loads without import errors\nfrom all_experiments_v2 import run_oracle_extended, run_threshold_var_wide, run_var2, run_alternative_signals, run_simulation_nio_baseline\nprint\\('All experiment functions imported successfully'\\)\n\n# Test that run_factor_neutral_sim.py loads\nfrom run_factor_neutral_sim import run_single_trial, run_table2_simulation\nprint\\('run_factor_neutral_sim imported successfully'\\)\n\n# Test that oracle_nio_power.py loads\nfrom oracle_nio_power import run_power_analysis\nprint\\('oracle_nio_power imported successfully'\\)\n\n# Test that empirical_portfolio_sort.py loads\nfrom empirical_portfolio_sort import portfolio_sort, compute_portfolio_stats\nprint\\('empirical_portfolio_sort imported successfully'\\)\n\n# Quick functional test: run 1 trial of Exp3 logic\nimport numpy as np\nfrom dgp import generate_sparse_var\nfrom factor_neutral_preprocessing import preprocess_returns\nfrom te_core import compute_linear_te_matrix, compute_nio\nfrom evaluation import eval_metrics\n\nN, T = 10, 50\nR, A_coef, A_true, F_true = generate_sparse_var\\(N=N, T=T, density=0.05, seed=42, dgp='garch_factor', return_factors=True\\)\nR_oracle, diag = preprocess_returns\\(R, mode='oracle_fn', true_factors=F_true\\)\nR_est, diag2 = preprocess_returns\\(R, mode='estimated_fn', n_factors=3\\)\n_, A_ols = compute_linear_te_matrix\\(R_oracle, method='ols', t_threshold=2.0\\)\nm = eval_metrics\\(A_true, A_ols, top_k=3\\)\nprint\\(f'Quick trial: precision={m[\\\\\"precision\\\\\"]:.3f}, recall={m[\\\\\"recall\\\\\"]:.3f}, f1={m[\\\\\"f1\\\\\"]:.3f}, kendall_tau={m[\\\\\"kendall_tau\\\\\"]:.3f}'\\)\nprint\\(\\)\nprint\\('ALL IMPORT AND FUNCTIONAL TESTS PASSED'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys\nsys.path.insert\\(0, 'src'\\)\n# Test: NIO direction consistency across all modules\nimport numpy as np\nfrom algorithms import compute_nio\nfrom extended_dgp_planted_signal import generate_sparse_var_with_nio_premium\n\n# Generate data with planted signal\nR, A, A_true, NIO_std = generate_sparse_var_with_nio_premium\\(N=20, T=100, density=0.1, seed=42, dgp='gaussian', lambda_NIO=0.01\\)\n\n# Compute NIO from algorithms.py\nnio_algo = compute_nio\\(A_true.astype\\(float\\), method='binary'\\)\n\n# Compute NIO manually following planted_signal.py convention\nout_flow = A_true.sum\\(axis=0\\)  # col sums\nin_flow = A_true.sum\\(axis=1\\)   # row sums\nnio_manual = \\(out_flow - in_flow\\) / \\(20 - 1\\)\n\n# These should match \\(both use same axis convention\\)\nprint\\('NIO from algorithms.py:', nio_algo[:5]\\)\nprint\\('NIO from manual \\(col-row\\):', nio_manual[:5]\\)\ncorr = np.corrcoef\\(nio_algo, nio_manual\\)[0,1]\nprint\\(f'Correlation: {corr:.6f}'\\)\nassert corr > 0.99, f'FAIL: NIO direction mismatch, corr={corr}'\nprint\\(\\)\n\n# Also check that planted_signal standardized NIO correlates with algo NIO\nnio_planted_raw = \\(out_flow - in_flow\\) / \\(20 - 1\\)\nnio_planted_std = \\(nio_planted_raw - nio_planted_raw.mean\\(\\)\\) / \\(nio_planted_raw.std\\(\\) + 1e-10\\)\ncorr2 = np.corrcoef\\(nio_algo, nio_planted_std\\)[0,1]\nprint\\(f'Correlation with planted NIO \\(standardized\\): {corr2:.6f}'\\)\nassert abs\\(corr2\\) > 0.99, f'FAIL: planted NIO direction mismatch'\n\nprint\\(\\)\nprint\\('NIO DIRECTION CONSISTENCY: PASS'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys\nsys.path.insert\\(0, 'src'\\)\n# Test: run_factor_neutral_sim.py Table 2 aggregation logic works end-to-end\n# This catches the latent kendall_tau KeyError that was fixed\nfrom run_factor_neutral_sim import run_single_trial\nimport numpy as np\n\nm = run_single_trial\\(N=10, T=30, density=0.05, seed=42, dgp='garch_factor', preprocessing='estimated_fn', method='ols'\\)\nprint\\('run_single_trial returned keys:', sorted\\(m.keys\\(\\)\\)\\)\nrequired = ['precision', 'recall', 'f1', 'hub_recovery', 'density', 'kendall_tau']\nfor k in required:\n    assert k in m, f'Missing key: {k}'\n    print\\(f'  {k}: {m[k]:.4f}'\\)\nprint\\('Table 2 aggregation: PASS'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\n# Check for any remaining bare except clauses or other code quality issues\nimport ast, sys\nfrom pathlib import Path\n\nissues = []\nsrc_files = list\\(Path\\('src'\\).glob\\('*.py'\\)\\) + list\\(Path\\('scripts'\\).glob\\('*.py'\\)\\) + [Path\\('run_experiments_modular.py'\\), Path\\('compare_runs.py'\\), Path\\('test_algorithms.py'\\)]\n\nfor f in src_files:\n    try:\n        tree = ast.parse\\(f.read_bytes\\(\\)\\)\n    except SyntaxError as e:\n        issues.append\\(f'{f}: SYNTAX ERROR: {e}'\\)\n        continue\n    \n    for node in ast.walk\\(tree\\):\n        # Check for bare except\n        if isinstance\\(node, ast.ExceptHandler\\):\n            if node.type is None:\n                # bare except\n                issues.append\\(f'{f}:{node.lineno}: bare except clause'\\)\n\nif issues:\n    print\\('ISSUES FOUND:'\\)\n    for i in issues:\n        print\\(f'  {i}'\\)\nelse:\n    print\\('No bare except clauses or syntax errors found'\\)\nprint\\(\\)\n\n# Count lines\ntotal = 0\nfor f in src_files:\n    lines = len\\(f.read_text\\(encoding='utf-8', errors='ignore'\\).splitlines\\(\\)\\)\n    total += lines\n    # Only print src files\n    if str\\(f\\).startswith\\('src'\\):\n        print\\(f'{f}: {lines} lines'\\)\nprint\\(f'Total across all files: {total} lines'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\nimport sys\nsys.path.insert\\(0, 'src'\\)\n# Check for any remaining duplicate implementations\n# Search for NIO computation patterns outside algorithms.py\nfrom pathlib import Path\n\ntarget_patterns = [\n    '.sum\\(axis=1\\) - ',  # old NIO pattern \\(wrong direction\\)\n    '.sum\\(axis=0\\) - ',  # could be NIO or hub computation\n    'out_flow - in_flow',  # NIO formula\n]\n\nfor p in Path\\('src'\\).glob\\('*.py'\\):\n    if p.name == 'algorithms.py':\n        continue  # skip the canonical source\n    content = p.read_text\\(encoding='utf-8', errors='ignore'\\)\n    for pat in target_patterns:\n        if pat in content:\n            # Check context\n            for i, line in enumerate\\(content.splitlines\\(\\), 1\\):\n                if pat in line and not line.strip\\(\\).startswith\\('#'\\):\n                    print\\(f'{p}:{i}: {line.strip\\(\\)[:100]}'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\n# Check that the planted signal NIO uses correct axis convention\nimport sys\nsys.path.insert\\(0, 'src'\\)\ncontent = open\\('src/extended_dgp_planted_signal.py'\\).read\\(\\)\n# Check lines 48-50\nlines = content.splitlines\\(\\)\nfor i in range\\(47, 51\\):\n    print\\(f'{i+1}: {lines[i]}'\\)\n# Line 48: out_flow = A_true.sum\\(axis=0\\)  # col sums = out-degree  CORRECT\n# Line 49: in_flow = A_true.sum\\(axis=1\\)   # row sums = in-degree   CORRECT\nprint\\(\\)\nprint\\('Convention check:'\\)\nprint\\('  A[i,j] = j->i, so col j sums = out-flow from j, row i sums = in-flow to i'\\)\nprint\\('  axis=0 \\(col sums\\) = out-degree: CORRECT'\\)\nprint\\('  axis=1 \\(row sums\\) = in-degree: CORRECT'\\)\n\" 2>&1)",
      "Bash(cd /c/Users/soray/.openclaw/workspace/te-network-audit && python -c \"\n# Final check: verify all cross-imports work correctly\n# This catches any circular import or missing module issues\nimport sys\nsys.path.insert\\(0, 'src'\\)\n\n# Every src module\nmodules = [\n    'algorithms', 'te_core', 'dgp', 'evaluation',\n    'extended_dgp', 'extended_dgp_planted_signal',\n    'factor_neutral_preprocessing',\n    'nonparametric_te',\n]\n\nfor mod in modules:\n    try:\n        __import__\\(mod\\)\n        print\\(f'  OK: {mod}'\\)\n    except Exception as e:\n        print\\(f'  FAIL: {mod} -> {e}'\\)\n\nprint\\(\\)\nprint\\('Import chain verification complete'\\)\n\" 2>&1)"
    ]
  }
}
